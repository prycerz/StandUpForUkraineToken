// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract YourToken is ERC20 {
    address public specialWallet;
    uint256 public totalRewards = 1000000;
    uint256 public emissionTimestamp;
    uint256 public lastDistributionTimestamp;
    uint256 public distributionsCount;
    uint256 public totalTransactions;

    mapping(address => uint256) public totalTransactionAmounts;
    mapping(address => uint256) public startOfWindow;

     // Declaration of the rewardAddresses array.
    address[] public rewardAddresses;

    constructor(address _specialWallet) ERC20("StandUpForUkraineToken", "SUFU") {
        require(_specialWallet != address(0), "Special wallet cannot be the zero address");

        specialWallet = 0xea1fDC0223005f1e6ee8862cC1Bb7bD2c50867FB;

        // Setting the time of first emition
        emissionTimestamp = block.timestamp;

        // Generating a million of coins for special wallet at the very beginning
        _mint(specialWallet, 1000000 * (10**decimals()));

        // Fisrt distribution after 30 days since first emission
        lastDistributionTimestamp = emissionTimestamp + 30 days;
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        uint256 taxAmount = (amount * 10) / 100;

        super.transfer(specialWallet, taxAmount);
        super.transfer(recipient, amount - taxAmount);

        totalTransactionAmounts[msg.sender] += amount;
        totalTransactions += amount;

        updateMonthlyReward(msg.sender);

        // Adding automatic distribution after 30 days
        if (block.timestamp >= lastDistributionTimestamp + 30 days) {
            distributeRewards();
        }

        return true;
    }

    function distributeRewards() internal {
        // Checking if 30 days are gone since first distribution
        if (block.timestamp >= lastDistributionTimestamp + 30 days) {
            // Counting new tokens to be given
            uint256 monthlyReward = 1000000 * (10**decimals());

            // Adding new tokens to existing wallets
            for (uint256 i = 0; i < rewardAddresses.length; i++) {
                address account = rewardAddresses[i];
                uint256 accountTransactions = totalTransactionAmounts[account];
                uint256 accountReward = (accountTransactions * monthlyReward) / totalTransactions;

                // Adding new tokens to existing wallets as a reward
                _mint(account, accountReward);

                // Restart of window time for current time
                startOfWindow[account] = block.timestamp;
            }

            // Restart of statistic and time
            totalTransactions = 0;
            lastDistributionTimestamp = block.timestamp;
            distributionsCount++;
        }
    }

    function updateMonthlyReward(address account) internal {
        totalTransactionAmounts[account] += totalTransactions;

        // Checking if one month (30 days) since last partiotion (drop) has gone
        if (block.timestamp >= lastDistributionTimestamp + 30 days) {
            // Resetting the start time of the time window to the current time.
            startOfWindow[account] = block.timestamp;
        }
    }
}
