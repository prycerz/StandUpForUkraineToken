// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract YourToken is ERC20 {
    address public specialWallet;
    address public rewardWallet;
    uint256 public totalRewards = 1000000;
    uint256 public emissionTimestamp;
    uint256 public lastDistributionTimestamp;
    uint256 public distributionsCount;
    uint256 public totalTransactions;

    mapping(address => uint256) public totalTransactionAmounts;
    mapping(address => uint256) public startOfWindow;
    mapping(address => uint256) public rewardsPerAddress;

    // Declaration of table rewardAddresses
    address[] public rewardAddresses;

    constructor(address _specialWallet, address _rewardWallet) ERC20("StandUpForUkraineToken", "SUFU") {
        require(_specialWallet != address(0), "Special wallet cannot be the zero address");
        require(_rewardWallet != address(0), "Reward wallet cannot be the zero address");

        specialWallet = 0xea1fDC0223005f1e6ee8862cC1Bb7bD2c50867FB;
        rewardWallet = _rewardWallet;

        // Setting the time for the initial issuance.
        emissionTimestamp = block.timestamp;

        // Generating 1,000,000 tokens for a special wallet initially.
        _mint(specialWallet, 1000000 * (10**decimals()));

        // Setting the time for the first distribution 30 days after issuance.
        lastDistributionTimestamp = emissionTimestamp + 30 days;
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        uint256 taxAmount = (amount * 10) / 100;

        super.transfer(specialWallet, taxAmount);
        super.transfer(recipient, amount - taxAmount);

        totalTransactionAmounts[msg.sender] += amount;
        totalTransactions += amount;

        updateMonthlyReward(msg.sender);

        // Implementing automatic distribution after 30 days from the issuance time.
        if (block.timestamp >= lastDistributionTimestamp + 30 days) {
            distributeRewards();
        }

        return true;
    }

    function distributeRewards() internal {
        // Checking if a month has passed since the last distribution.
        if (block.timestamp >= lastDistributionTimestamp + 30 days) {
            // Calculating the amount of new tokens to distribute.
            uint256 monthlyReward = 1000000 * (10**decimals());

            // Allocating tokens based on the percentage share of transactions.
            for (uint256 i = 0; i < rewardAddresses.length; i++) {
                address account = rewardAddresses[i];
                uint256 accountTransactions = totalTransactionAmounts[account];
                uint256 accountReward = (accountTransactions * monthlyReward) / totalTransactions;

                // Allocating new tokens to existing wallets.
                rewardsPerAddress[account] += accountReward;

                // Resetting the start time of the time window to the current time.
                startOfWindow[account] = block.timestamp;
            }

            // Allocating rewards to existing wallets.
            for (uint256 i = 0; i < rewardAddresses.length; i++) {
                address account = rewardAddresses[i];
                super.transfer(account, rewardsPerAddress[account]);

                // Adding new tokens to the pool.
                _mint(rewardWallet, monthlyReward);

                rewardsPerAddress[account] = 0;
            }

            // Resetting statistics and time
            totalTransactions = 0;
            lastDistributionTimestamp = block.timestamp;
            distributionsCount++;
        }
    }

    function updateMonthlyReward(address account) internal {
        totalTransactionAmounts[account] += totalTransactions;

        // Checking if a month has passed since the last distribution.
        if (block.timestamp >= lastDistributionTimestamp + 30 days) {
            // Resetting the start time of the time window to the current time
            startOfWindow[account] = block.timestamp;
        }
    }
}
