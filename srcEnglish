// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract YourToken is ERC20 {
    address public specialWallet;
    uint256 public totalRewards = 1000000;
    uint256 public emissionTimestamp;
    uint256 public lastDistributionTimestamp;
    uint256 public distributionsCount;
    uint256 public totalTransactions;

    mapping(address => uint256) public totalTransactionAmounts;
    mapping(address => uint256) public startOfWindow;

    // Declaration of the rewardAddresses array.
    address[] public rewardAddresses;

    constructor(address _specialWallet) ERC20("StandUpForUkraineToken", "SUFU") {
        require(_specialWallet != address(0), "Special wallet cannot be the zero address");

        specialWallet = 0xea1fDC0223005f1e6ee8862cC1Bb7bD2c50867FB;

        // Setting the time of the first emission.
        emissionTimestamp = block.timestamp;

        // Generating 1000000 tokens for a special wallet at the beginning.
        _mint(specialWallet, 1000000 * (10**decimals()));

        // Setting the time for the first distribution after 30 days from emission.
        lastDistributionTimestamp = emissionTimestamp + 30 days;
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        uint256 taxAmount = (amount * 2) / 100;

        super.transfer(specialWallet, taxAmount);
        super.transfer(recipient, amount - taxAmount);

        totalTransactionAmounts[msg.sender] += amount;
        totalTransactions += amount;

        updateMonthlyReward(msg.sender);

        // Added automatic distribution after 30 days from the emission time.
        if (block.timestamp >= lastDistributionTimestamp + 30 days) {
            distributeRewards();
        }

        // Automatically add new addresses to the rewardAddresses array.
        if (!isRewardAddress(msg.sender)) {
            rewardAddresses.push(msg.sender);
        }

        return true;
    }

    // Function checking whether the address is already in the rewardAddresses array.
    function isRewardAddress(address account) internal view returns (bool) {
        for (uint256 i = 0; i < rewardAddresses.length; i++) {
            if (rewardAddresses[i] == account) {
                return true;
            }
        }
        return false;
    }

    // Function for adding new addresses eligible for rewards.
    function addRewardAddress(address newRewardAddress) external {
        require(msg.sender == specialWallet, "Only the special wallet can add reward addresses");
        require(newRewardAddress != address(0), "Reward address cannot be the zero address");

        // Adding a new address to the array.
        rewardAddresses.push(newRewardAddress);
    }

    // Funkcja rozdzielająca nagrody
    function distributeRewards() internal {
        // Sprawdzenie, czy minął miesiąc od ostatniej dystrybucji
        if (block.timestamp >= lastDistributionTimestamp + 30 days) {
            // Obliczenie ilości nowych tokenów do rozdania
            uint256 monthlyReward = 1000000 * (10**decimals());

            // Przydzielanie nagród do istniejących portfeli
            for (uint256 i = 0; i < rewardAddresses.length; i++) {
                address account = rewardAddresses[i];
                uint256 accountTransactions = totalTransactionAmounts[account];
                uint256 accountReward = (accountTransactions * monthlyReward) / totalTransactions;

                // Przydzielanie nowych tokenów do istniejących portfeli jako nagroda
                _mint(account, accountReward);

                // Resetowanie czasu początkowego okna czasowego na aktualny czas
                startOfWindow[account] = block.timestamp;
            }

            // Resetowanie statystyk i czasu
            totalTransactions = 0;
            lastDistributionTimestamp = block.timestamp;
            distributionsCount++;
        }
    }

    // Function updating monthly rewards for a given account.
    function updateMonthlyReward(address account) internal {
        totalTransactionAmounts[account] += totalTransactions;

        // Checking if a month has passed since the last distribution.
        if (block.timestamp >= lastDistributionTimestamp + 30 days) {
          // Resetting the start time of the time window to the current time.
            startOfWindow[account] = block.timestamp;
        }
    }
}
