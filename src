// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;


import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract YourToken is ERC20 {
    address public specialWallet;
    address public rewardWallet;
    uint256 public totalRewards = 1000000;
    uint256 public lastDistributionTimestamp;
    uint256 public distributionsCount;
    bool public rewardReductionActivated;

    mapping(address => uint256) public totalTransactionAmounts;

    constructor(address _specialWallet, address _rewardWallet) ERC20("StandUpForUkraineToken", "SUFU") {

     require(_specialWallet != address(0), "Special wallet cannot be the zero address");
    require(_rewardWallet != address(0), "Reward wallet cannot be the zero address");

        specialWallet = 0xea1fDC0223005f1e6ee8862cC1Bb7bD2c50867FB;
        rewardWallet = 0x766a54da8de513579C801A113521c4135D04C135;
        lastDistributionTimestamp = block.timestamp;

        // Wygenerowanie 1000000 tokenów na specjalny portfel
        _mint(specialWallet, 1000000 * (9**decimals()));

            // Ustawienie maksymalnej ilości tokenów
    uint256 maxSupply = 50000000 * (9**decimals());
    require(totalSupply() <= maxSupply, "Total supply exceeds maximum supply");
}
     
    // Funkcja do opodatkowywania transakcji 10% na rzecz specjalnego portfela
    function transfer(address recipient, uint256 amount) public override returns (bool) {
        uint256 taxAmount = (amount * 10) / 100;

        // Przekazanie 10% środków do specjalnego portfela
        super.transfer(specialWallet, taxAmount);

        // Przekazanie reszty środków do odbiorcy
        super.transfer(recipient, amount - taxAmount);

        // Zliczanie kwoty nominalnej transakcji na koncie wysyłającego
        totalTransactionAmounts[msg.sender] += amount;

        return true;
    }

    // Funkcja do zliczania łącznej kwoty nominalnej transakcji dla Twojego tokenu
    function calculateTotalTransactionAmount() public view returns (uint256) {
        uint256 totalAmount = 0;

        // Iteracja przez wszystkie adresy i dodanie ich transakcji do ogólnej kwoty
     for (uint256 i = 0; i < balanceOf(address(this)); i++) {
            address account = tokenByIndex(i);
            totalAmount += totalTransactionAmounts[account];
        }

        return totalAmount;
    }

    // Funkcja do przyznawania nagród w zależności od udziału transakcji
    function distributeRewards() public {
        require(msg.sender == rewardWallet, "Only the reward wallet can distribute rewards");

        // Sprawdzenie, czy minął miesiąc od ostatniej dystrybucji
        require(block.timestamp >= lastDistributionTimestamp + 30 days, "Monthly distribution not yet allowed");

        uint256 totalTransactions = calculateTotalTransactionAmount();

        // Redukcja puli nagród po 50 dystrybucjach
        if (distributionsCount >= 50 && !rewardReductionActivated) {
            rewardReductionActivated = true;
            totalRewards = 0; // Zmniejszenie puli nagród do zera
        }

        for (uint256 i = 0; i < totalSupply(); i++) {
            address account = tokenByIndex(i);
            uint256 accountTransactions = totalTransactionAmounts[account];
            uint256 accountReward = (accountTransactions * totalRewards) / totalTransactions;

            // Przydziel nagrodę dla posiadacza tokenów
            super.transfer(account, accountReward);
        }

        // Aktualizacja timestampu ostatniej dystrybucji
        lastDistributionTimestamp = block.timestamp;
        distributionsCount++;
    }
}
